---
layout : posts
title : 그래프이론
categories : 쿠다ML심화
---
# 18. 그래프 이론 및 네트워크 분석
## 18.1 기본 그래프 이론으로 인기도별 웹 사이트 순위 지정하기
***넘파이는 확장하는 네트워크를 분석하는 적합한 도구인가?***

예시 : 인기도에 따라 웹사이트 순위 매기는 작업

넘파이 튜토리얼(0) 및 사이파이 튜토리얼(1)을 다루는 두 데이터 과학 웹사이트로 간단한 네트워크 구축

각 웹사이트 : 그래프의 **노드**

  → 서로 연결부를 형성할 수 있는 지점

두 노드를 연결한 것 : **에지**

```python
nodes = ['넘파이', '사이파이'] #각 인덱스는 0,1
```
가정 : 사이파이 웹사이트[1]에서 넘파이 웹사이트[0]으로의 종속성 논의 : 클릭 시 nodes[1] → nodes[0], 에지 = (1,0)

![image](https://github.com/user-attachments/assets/c4d7a34d-76b9-42b5-9f5a-e8640beb1df0)

단일 에지 (1,0)은 방향을 갖기에 **방향성 에지**로 표현 가능 (방향성 그래프의 에지(i,j) != 에지(j,i), 사이파이 페이지만 넘파이 페이지에 연결되었고, 그 반대는 아직 이루어지지 않은 상태)

에지 유무를 확인하기 위한 방법 中 하나 : **인접 행렬**

→ not edge_exists (i,j) = 0, edge_exists (i,j) = 1로 표현하여 노드 i와 j 사이에 에지가 있는 곳에만 M[i][j] = 1이 채워진 행렬을 표현

행렬의 크기는 node수의 제곱이 되겠다! (len(nodes)^2, 이진 행렬이면 2X2, 웹페이지가 4개면 4X4)

웹페이지가 추가되면, 행렬의 크기도 늘어나야 한다. but, 넘파이로는 기존 행렬의 모든 값 유지하면서 행렬 크기를 조정하기 어려움 : 다른 파이썬 라이브러리로 전환 필요 (=NetworkX, 네트워크를 쉽게 수정할 수 있는 라이브러리)

### 18.1.1 NetworkX로 웹 네트워크 분석하기
***방향성 그래프***
```matlab
📘 NetworkX 그래프 메서드 
🔹 G = nx.DiGraph() : 방향성 그래프(Directed Graph)를 생성합니다.
🔹 G.add_node(1) : 노드 1을 추가합니다.
🔹 G.nodes[1]['color'] = 'red' : 노드 1에 'color' 속성으로 'red'를 설정합니다.
🔹 G.add_node(2, size=10) : 속성 'size=10'을 가진 노드 2를 추가합니다.
🔹 G.add_nodes_from([3, 4]) : 노드 3, 4를 한 번에 추가합니다.
🔹 G.add_nodes_from([(5, {'label': 'A'}), (6, {'label': 'B'})])
🔹 G.add_edge(1, 2) : 노드 1 ➝ 2 방향으로 간선을 추가합니다.
🔹 G.add_edges_from([(2, 3), (3, 4)]) : 노드 2 ➝ 3, 3 ➝ 4 간선을 추가합니다.
✅ 최종 노드 목록: [(1, {'color': 'red'}), (2, {'size': 10}), (3, {}), (4, {}), (5, {'label': 'A'}), (6, {'label': 'B'})]
✅ 최종 간선 목록: [(1, 2), (2, 3), (3, 4)]
```
이 방법을 써서 인터넷에서 웹사이트 순위를 매기는 지표를 확인하는 방법

![image](https://github.com/user-attachments/assets/63ad5a51-d0a7-4cf3-b1dd-8e5ae542b3a7)

1. G.Draw() 메소드를 써서 가장 많이 지목받는 웹사이트 파악 (**인-디그리**)

2. 행렬을 사용하여 각 열의 합이 최대가 되는 지점을 통해 웹사이트 파악

18.1.1은 노드 간 이동이 제한된 방향성 그래프. 모든 에지를 양방향 도로처럼 취급하면 어떨까? : 비방향성 그래프

## 18.2 비방향성 그래프로 마을 간 이동 시간 최적화하기
예시) 스마트폰 길찾기를 사용할 수 없는 상황에서 최적의 제품 배송 시간을 구하는 방법에 대하여

여러 마을의 이동시간 최적화는 복잡한 문제, 지역은 6개고 그 안에는 3~10개의 마을이 존재.

5개의 마을을 연결해보자. (각 노드는 90%의 확률로 연결됨)

![image](https://github.com/user-attachments/assets/2083a52e-6189-4b5a-9ea6-dcdad006136e)

위 그림처럼 생성된 두 지역의 마을을 동일 그래프로 표현한 것에서 지역 사이에 임의의 도로를 연결하면 아래와 같다.

![image](https://github.com/user-attachments/assets/1096d27e-cb7d-4fc3-aef8-0f2c2ab90c64)

이러한 방식으로 여러 지역의 도로를 연결할 수 있다. 

![image](https://github.com/user-attachments/assets/f78886f0-1181-44f0-8997-9c711990df3c)

# 19. 노드 순위 매기기 및소셜 네트워크 분석을 위한 동적 그래프 이론 기법
![image](https://github.com/user-attachments/assets/a44179dd-b24d-4662-b0b9-e76234ef248c)

그림으로 보기에 마을 12가 마을 3보다 더 중심지에 위치하여 중요지로 직관적 인식되지만, adjacency_matrix.sum(axis=0).argmax() 결과 디그리가 동일, 즉 중심도가 동일함을 알 수 있다. 이를 어떻게 해결할 수 있을까? → 임의 시뮬레이션을 통한 차이 정량화

### 19.1.1 교통 시뮬레이션으로 중심도 측정하기
실제 현실에서는 사람들이 목적지를 갖고 이동하기에 랜덤으로 이동하지 않지만, 모델을 단순화하여 교통 시뮬레이션을 돌려보자. 돌린 결과 마을 12의 교통량이 가장 많다. 시뮬레이션 실행 횟수를 분모에 넣어 확률로 비교하면 쉽게 분석할 수 있지만, 그래프가 클 수록 시뮬레이션 결과가 느려져 효율적이지 못하다.

## 19.2 행렬 곱셈으로 이동 확률 계산하기
전이 벡터 : 마을에서 다른 마을로 이동할 확률을 추적한 벡터 (p = 1/G.degree(0), v[i]가 G[x]에 속할 때는 값이 있고, otherwise 0)





